#include <vector>
#include <interpolation.h>
#include <ap.h>

#include <perl_myinit.h>

%module{Math::Alglib};
%package{Math::Alglib::Interpolation};

//////////////////////////////////////////////////////////////////////
%name{Math::Alglib::Interpolation::IdwInterpolant}
class idwinterpolant {
  ~idwinterpolant();

  double
  idwcalc(real_1d_array x)
    %code{%
      RETVAL = alglib::idwcalc(*THIS, x);
    %};
};

//////////////////////////////////////////////////////////////////////
%name{Math::Alglib::Interpolation::BarycentricInterpolant}
class barycentricinterpolant {
  ~barycentricinterpolant();

  double
  barycentriccalc(const double t)
    %code{%
      RETVAL = alglib::barycentriccalc(*THIS, t);
    %};

  std::vector<double>
  barycentricdiff1(const double t)
    %code{%
      RETVAL.resize(2);
      alglib::barycentricdiff1(*THIS, t, RETVAL[0], RETVAL[1]);
    %};

  std::vector<double>
  barycentricdiff2(const double t)
    %code{%
      RETVAL.resize(3);
      alglib::barycentricdiff2(*THIS, t, RETVAL[0], RETVAL[1], RETVAL[2]);
    %};

  void
  barycentriclintransx(const double ca, const double cb)
    %code{% alglib::barycentriclintransx(*THIS, ca, cb); %};

  void
  barycentriclintransy(const double ca, const double cb)
    %code{% alglib::barycentriclintransy(*THIS, ca, cb); %};

  void
  barycentricunpack()
    %code%{
      ae_int_t n;
      real_1d_array x, y, w;
      barycentricunpack(*THIS, n, x, y, w);
      EXTEND(SP, 4);
      mPUSHi(n);
      mPUSHs(sv_2mortal(newRV_noinc((SV *)real_1d_array_to_av(aTHX_ x))));
      mPUSHs(sv_2mortal(newRV_noinc((SV *)real_1d_array_to_av(aTHX_ y))));
      mPUSHs(sv_2mortal(newRV_noinc((SV *)real_1d_array_to_av(aTHX_ w))));
      XSRETURN(4);
    %};

  real_1d_array
  polynomialbar2cheb(const double a, const double b)
    %code{% alglib::polynomialbar2cheb(*THIS, a, b, RETVAL); %};

  real_1d_array
  polynomialbar2pow(const double c, const double s)
    %code{% alglib::polynomialbar2pow(*THIS, c, s, RETVAL); %};
};

//////////////////////////////////////////////////////////////////////
%name{Math::Alglib::Interpolation::Spline1dInterpolant}
class spline1dinterpolant {
  ~spline1dinterpolant();

  double spline1dcalc(const double x)
    %code{%
      RETVAL = alglib::spline1dcalc(*THIS, x);
    %};

  void
  spline1ddiff(const double x)
    %code{%
      double s, ds, d2s;
      alglib::spline1ddiff(*THIS, x, s, ds, d2s);
      EXTEND(SP, 3);
      mPUSHn(s); mPUSHn(ds); mPUSHn(d2s);
    %};

  real_2d_array
  spline1dunpack()
    %code{%
      ae_int_t n;
      alglib::spline1dunpack(*THIS, n, RETVAL);
    %};

  void
  spline1dlintransx(const double a, const double b)
    %code{% alglib::spline1dlintransx(*THIS, a, b); %};

  void
  spline1dlintransy(const double a, const double b)
    %code{% alglib::spline1dlintransy(*THIS, a, b); %};

  double
  spline1dintegrate(const double x)
    %code{%
      RETVAL = alglib::spline1dintegrate(*THIS, x);
    %};

};

//////////////////////////////////////////////////////////////////////
%name{Math::Alglib::Interpolation::PSpline2Interpolant}
class pspline2interpolant {
  ~pspline2interpolant();

  AV *
  pspline2parametervalues()
    %code{%
      sv_2mortal((SV *)RETVAL);
      ae_int_t n;
      real_1d_array t;
      alglib::pspline2parametervalues(*THIS, n, t);
      av_extend(RETVAL, 1);
      av_store(RETVAL, 0, newSViv(n));
      av_store(RETVAL, 1, newRV_noinc((SV *)real_1d_array_to_av(aTHX_ t)));
    %};

{%
AV *
pspline2interpolant::pspline2calc(const double t)
  ALIAS:
    calc = 1
    pspline2tangent = 2
    tangent = 3
    pspline2diff = 4
    diff = 5
    pspline2diff2 = 6
    diff2 = 7
  CODE:
    sv_2mortal((SV *)RETVAL);
    double x, y;
    if (ix <= 3) {
      if (ix <= 1)
        alglib::pspline2calc(*THIS, t, x, y);
      else
        alglib::pspline2tangent(*THIS, t, x, y);
      av_extend(RETVAL, 1);
      av_store(RETVAL, 0, newSVnv(x));
      av_store(RETVAL, 1, newSVnv(y));
    }
    else {
      double dx, dy;
      if (ix <= 5) {
        alglib::pspline2diff(*THIS, t, x, dx, y, dy);
        av_extend(RETVAL, 3);
        av_store(RETVAL, 0, newSVnv(x));
        av_store(RETVAL, 1, newSVnv(dx));
        av_store(RETVAL, 2, newSVnv(y));
        av_store(RETVAL, 3, newSVnv(dy));
      }
      else {
        double dx2, dy2;
        alglib::pspline2diff2(*THIS, t, x, dx, dx2, y, dy, dy2);
        av_extend(RETVAL, 5);
        av_store(RETVAL, 0, newSVnv(x));
        av_store(RETVAL, 1, newSVnv(dx));
        av_store(RETVAL, 2, newSVnv(dx2));
        av_store(RETVAL, 3, newSVnv(y));
        av_store(RETVAL, 4, newSVnv(dy));
        av_store(RETVAL, 5, newSVnv(dy2));
      }
    }
  OUTPUT: RETVAL
%}

{%
double
pspline2interpolant::pspline2arclength(const double a, const double b)
  ALIAS:
    arclength = 1
  CODE:
    RETVAL = alglib::pspline2arclength(*THIS, a, b);
  OUTPUT: RETVAL
%}

}; // end class pspline2interpolant

{%
pspline2interpolant*
pspline2build(real_2d_array xy, const ae_int_t n, const ae_int_t st, const ae_int_t pt)
  ALIAS:
    pspline2buildperiodic = 1
  CODE:
    const char CLASS[] = "Math::Alglib::Interpolation::PSpline2Interpolant";
    RETVAL = new alglib::pspline2interpolant();
    if (ix == 0)
      alglib::pspline2build(xy, n, st, pt, *RETVAL);
    else
      alglib::pspline2buildperiodic(xy, n, st, pt, *RETVAL);
  OUTPUT: RETVAL
%}

//////////////////////////////////////////////////////////////////////
%name{Math::Alglib::Interpolation::Spline2dInterpolant}
class spline2dinterpolant {
  spline2dinterpolant();
  ~spline2dinterpolant();

  double spline2dcalc(const double x, const double y)
    %code{% RETVAL = alglib::spline2dcalc(*THIS, x, y); %};

  AV *
  spline2ddiff(const double x, const double y)
    %code{%
      sv_2mortal((SV *)RETVAL);
      double f, fx, fy, fxy;
      alglib::spline2ddiff(*THIS, x, y, f, fx, fy, fxy);
      av_extend(RETVAL, 4);
      av_store(RETVAL, 0, newSVnv(f));
      av_store(RETVAL, 1, newSVnv(fx));
      av_store(RETVAL, 2, newSVnv(fy));
      av_store(RETVAL, 3, newSVnv(fxy));
    %};

  void
  spline2dlintransxy(const double Ax, const double bx, const double ay, const double by)
    %code{% alglib::spline2dlintransxy(*THIS, Ax, bx, ay, by); %};

  void
  spline2dlintransf(const double a, const double b)
    %code{% alglib::spline2dlintransf(*THIS, a, b); %};

}; // end class spline2dinterpolant

//////////////////////////////////////////////////////////////////////
%name{Math::Alglib::Interpolation::PSpline3Interpolant}
class pspline3interpolant {
  ~pspline3interpolant();

{%
AV *
pspline3interpolant::pspline3parametervalues()
  CODE:
    sv_2mortal((SV *)RETVAL);
    ae_int_t n;
    real_1d_array t;
    alglib::pspline3parametervalues(*THIS, n, t);
    av_extend(RETVAL, 1);
    av_store(RETVAL, 0, newSViv(n));
    av_store(RETVAL, 1, newRV_noinc((SV *)real_1d_array_to_av(aTHX_ t)));
  OUTPUT: RETVAL
%}

{%
AV *
pspline3interpolant::pspline3calc(const double t)
  ALIAS:
    calc = 1
    pspline3tangent = 2
    tangent = 3
    pspline3diff = 4
    diff = 5
    pspline3diff2 = 6
    diff2 = 7
  CODE:
    sv_2mortal((SV *)RETVAL);
    double x, y, z;
    if (ix <= 3) {
      if (ix <= 1)
        alglib::pspline3calc(*THIS, t, x, y, z);
      else
        alglib::pspline3tangent(*THIS, t, x, y, z);
      av_extend(RETVAL, 2);
      av_store(RETVAL, 0, newSVnv(x));
      av_store(RETVAL, 1, newSVnv(y));
      av_store(RETVAL, 2, newSVnv(z));
    }
    else {
      double dx, dy, dz;
      if (ix <= 5) {
        alglib::pspline3diff(*THIS, t, x, dx, y, dy, z, dz);
        av_extend(RETVAL, 5);
        av_store(RETVAL, 0, newSVnv(x));
        av_store(RETVAL, 1, newSVnv(dx));
        av_store(RETVAL, 2, newSVnv(y));
        av_store(RETVAL, 3, newSVnv(dy));
        av_store(RETVAL, 4, newSVnv(z));
        av_store(RETVAL, 5, newSVnv(dz));
      }
      else {
        double dx2, dy2, dz2;
        alglib::pspline3diff2(*THIS, t, x, dx, dx2, y, dy, dy2, z, dz, dz2);
        av_extend(RETVAL, 8);
        av_store(RETVAL, 0, newSVnv(x));
        av_store(RETVAL, 1, newSVnv(dx));
        av_store(RETVAL, 2, newSVnv(dx2));
        av_store(RETVAL, 3, newSVnv(y));
        av_store(RETVAL, 4, newSVnv(dy));
        av_store(RETVAL, 5, newSVnv(dy2));
        av_store(RETVAL, 6, newSVnv(z));
        av_store(RETVAL, 7, newSVnv(dz));
        av_store(RETVAL, 8, newSVnv(dz2));
      }
    }
  OUTPUT: RETVAL
%}

{%
double
pspline3interpolant::pspline3arclength(const double a, const double b)
  ALIAS:
    arclength = 1
  CODE:
    RETVAL = alglib::pspline3arclength(*THIS, a, b);
  OUTPUT: RETVAL
%}
}; // end class pspline3interpolant

{%
pspline3interpolant*
pspline3build(real_2d_array xy, const ae_int_t n, const ae_int_t st, const ae_int_t pt)
  ALIAS:
    pspline3buildperiodic = 1
  CODE:
    const char CLASS[] = "Math::Alglib::Interpolation::PSpline3Interpolant";
    RETVAL = new alglib::pspline3interpolant();
    if (ix == 0)
      alglib::pspline3build(xy, n, st, pt, *RETVAL);
    else
      alglib::pspline3buildperiodic(xy, n, st, pt, *RETVAL);
  OUTPUT: RETVAL
%}


//////////////////////////////////////////////////////////////////////
%name{Math::Alglib::Interpolation::RbfModel}
class rbfmodel {
  ~rbfmodel();

  std::string rbfserialize()
   %code{% alglib::rbfserialize(*THIS, RETVAL); %};

  void rbfsetpoints(real_2d_array xy)
    %code{% alglib::rbfsetpoints(*THIS, xy); %};

  void rbfsetalgoqnn(const double q, const double z)
    %code{% alglib::rbfsetalgoqnn(*THIS, q, z); %};

  void rbfsetalgomultilayer(const double rbase, const ae_int_t nlayers, const double lambdav)
    %code{% alglib::rbfsetalgomultilayer(*THIS, rbase, nlayers, lambdav); %};

  void rbfsetlinterm() %code{% alglib::rbfsetlinterm(*THIS); %};
  void rbfsetconstterm() %code{% alglib::rbfsetconstterm(*THIS); %};
  void rbfsetzeroterm() %code{% alglib::rbfsetzeroterm(*THIS); %};

  ae_int_t
  rbfbuildmodel()
    %code{%
      alglib::rbfreport rep;
      alglib::rbfbuildmodel(*THIS, rep);
      RETVAL = rep.terminationtype;
    %};

  double rbfcalc2(const double x0, const double x1)
    %code{% RETVAL = alglib::rbfcalc2(*THIS, x0, x1); %};

  double rbfcalc3(const double x0, const double x1, const double x2)
    %code{% RETVAL = alglib::rbfcalc3(*THIS, x0, x1, x2); %};

  real_1d_array
  rbfcalc(real_1d_array x)
    %code{% alglib::rbfcalc(*THIS, x, RETVAL); %};

  real_2d_array
  rbfgridcalc2(real_1d_array x0, const ae_int_t n0, real_1d_array x1, const ae_int_t n1)
    %code{% alglib::rbfgridcalc2(*THIS, x0, n0, x1, n1, RETVAL); %};

  AV*
  rbfunpack()
    %code{%
      sv_2mortal((SV *)RETVAL);
      ae_int_t nx, ny, nc;
      real_2d_array xwr, v;
      alglib::rbfunpack(*THIS, nx, ny, xwr, nc, v);
      av_extend(RETVAL, 4);
      av_store(RETVAL, 0, newSViv(nx));
      av_store(RETVAL, 1, newSViv(ny));
      av_store(RETVAL, 2, newRV_noinc((SV *)real_2d_array_to_av(aTHX_ xwr)));
      av_store(RETVAL, 3, newSViv(nc));
      av_store(RETVAL, 4, newRV_noinc((SV *)real_2d_array_to_av(aTHX_ v)));
    %};

};

{%
rbfmodel*
rbfunserialize(std::string s)
  CODE:
    const char CLASS[] = "Math::Alglib::Interpolation::RbfModel";
    RETVAL = new alglib::rbfmodel();
    alglib::rbfunserialize(s, *RETVAL);
  OUTPUT: RETVAL
%}

{%
rbfmodel*
rbfcreate(const ae_int_t nx, const ae_int_t ny)
  CODE:
    const char CLASS[] = "Math::Alglib::Interpolation::RbfModel";
    RETVAL = new alglib::rbfmodel();
    alglib::rbfcreate(nx, ny, *RETVAL);
  OUTPUT: RETVAL
%}

//////////////////////////////////////////////////////////////////////
%package{Math::Alglib::Interpolation};

idwinterpolant*
idwbuildmodifiedshepard(real_2d_array xy, const ae_int_t n, const ae_int_t nx,
                         const ae_int_t d, const ae_int_t nq, const ae_int_t nw)
  %code{%
    const char CLASS[] = "Math::Alglib::Interpolation::IdwInterpolant";
    RETVAL = new alglib::idwinterpolant();
    alglib::idwbuildmodifiedshepard(xy, n, nx, d, nq, nw, *RETVAL);
  %};

idwinterpolant*
idwbuildmodifiedshepardr(real_2d_array xy, const ae_int_t n, const ae_int_t nx, const double r)
  %code{%
    const char CLASS[] = "Math::Alglib::Interpolation::IdwInterpolant";
    RETVAL = new alglib::idwinterpolant();
    alglib::idwbuildmodifiedshepardr(xy, n, nx, r, *RETVAL);
  %};

idwinterpolant*
idwbuildnoisy(real_2d_array xy, const ae_int_t n, const ae_int_t nx,
              const ae_int_t d, const ae_int_t nq, const ae_int_t nw)
  %code{%
    const char CLASS[] = "Math::Alglib::Interpolation::IdwInterpolant";
    RETVAL = new alglib::idwinterpolant();
    alglib::idwbuildnoisy(xy, n, nx, d, nq, nw, *RETVAL);
  %};

//////////////////////////////////////////////////////////////////////
barycentricinterpolant*
barycentricbuildxyw(real_1d_array x, real_1d_array y, real_1d_array w, const ae_int_t n)
  %code{%
    const char CLASS[] = "Math::Alglib::Interpolation::BarycentricInterpolant";
    RETVAL = new alglib::barycentricinterpolant();
    alglib::barycentricbuildxyw(x, y, w, n, *RETVAL);
  %};

barycentricinterpolant*
barycentricbuildfloaterhormann(real_1d_array x, real_1d_array y, const ae_int_t n, const ae_int_t d)
  %code{%
    const char CLASS[] = "Math::Alglib::Interpolation::BarycentricInterpolant";
    RETVAL = new alglib::barycentricinterpolant();
    alglib::barycentricbuildfloaterhormann(x, y, n, d, *RETVAL);
  %};

barycentricinterpolant*
polynomialcheb2bar(real_1d_array t, const double a, const double b)
  %code{%
    const char CLASS[] = "Math::Alglib::Interpolation::BarycentricInterpolant";
    RETVAL = new alglib::barycentricinterpolant();
    alglib::polynomialcheb2bar(t, a, b, *RETVAL);
  %};

barycentricinterpolant*
polynomialpow2bar(real_1d_array a, const ae_int_t n, const double c, const double s)
  %code{%
    const char CLASS[] = "Math::Alglib::Interpolation::BarycentricInterpolant";
    RETVAL = new alglib::barycentricinterpolant();
    alglib::polynomialpow2bar(a, n, c, s, *RETVAL);
  %};

barycentricinterpolant*
polynomialbuild(real_1d_array x, real_1d_array y)
  %code{%
    const char CLASS[] = "Math::Alglib::Interpolation::BarycentricInterpolant";
    RETVAL = new alglib::barycentricinterpolant();
    alglib::polynomialbuild(x, y, *RETVAL);
  %};

{%
barycentricinterpolant*
polynomialbuildcheb1(const double a, const double b, real_1d_array y)
  PREINIT:
    const char CLASS[] = "Math::Alglib::Interpolation::BarycentricInterpolant";
  ALIAS:
    alglib::polynomialbuildeqdist = 1
    alglib::polynomialbuildcheb2 = 2
  CODE:
    RETVAL = new alglib::barycentricinterpolant();
    if (ix == 0)
      alglib::polynomialbuildcheb1(a, b, y, *RETVAL);
    else if (ix == 1)
      alglib::polynomialbuildeqdist(a, b, y, *RETVAL);
    else
      alglib::polynomialbuildcheb2(a, b, y, *RETVAL);
  OUTPUT: RETVAL
%}
//////////////////////////////////////////////////////////////////////

double polynomialcalceqdist(const double a, const double b, real_1d_array f, const double t);
double polynomialcalccheb1(const double a, const double b, real_1d_array f, const double t);
double polynomialcalccheb2(const double a, const double b, real_1d_array f, const double t);

//////////////////////////////////////////////////////////////////////
spline1dinterpolant*
spline1dbuildlinear(real_1d_array x, real_1d_array y)
  %code{%
    const char CLASS[] = "Math::Alglib::Interpolation::Spline1dInterpolant";
    RETVAL = new alglib::spline1dinterpolant();
    alglib::spline1dbuildlinear(x, y, *RETVAL);
  %};

spline1dinterpolant*
spline1dbuildcubic(real_1d_array x, real_1d_array y, ae_int_t n,
                   ae_int_t boundltype = 0, double boundl = 0,
                   ae_int_t boundrtype = 0, double boundr = 0)
  %code{%
    const char CLASS[] = "Math::Alglib::Interpolation::Spline1dInterpolant";
    RETVAL = new alglib::spline1dinterpolant();
    alglib::spline1dbuildcubic(x, y, n, boundltype, boundl, boundrtype, boundr, *RETVAL);
  %};

real_1d_array
spline1dgriddiffcubic(real_1d_array x, real_1d_array y, ae_int_t n,
                      ae_int_t boundltype = 0, double boundl = 0,
                      ae_int_t boundrtype = 0, double boundr = 0)
  %code{%
    alglib::spline1dgriddiffcubic(x, y, n, boundltype, boundl, boundrtype, boundr, RETVAL);
  %};


real_1d_array
spline1dconvcubic(real_1d_array x, real_1d_array y, ae_int_t n,
                  ae_int_t boundltype, double boundl,
                  ae_int_t boundrtype, double boundr,
                  real_1d_array x2, const ae_int_t n2)
  %code{%
    alglib::spline1dconvcubic(x, y, n, boundltype, boundl, boundrtype, boundr, x2, n2, RETVAL);
  %};

void
spline1dconvdiffcubic(real_1d_array x, real_1d_array y, ae_int_t n,
                      ae_int_t boundltype, double boundl,
                      ae_int_t boundrtype, double boundr,
                      real_1d_array x2, const ae_int_t n2)
  %code{%
    real_1d_array y2, d2;
    alglib::spline1dconvdiffcubic(x, y, n, boundltype, boundl, boundrtype, boundr, x2, n2, y2, d2);
    EXTEND(SP, 2);
    {
      const unsigned int len = y2.length();
      mPUSHs(sv_2mortal(newRV_noinc((SV *)real_1d_array_to_av(aTHX_ y2))));
    }
    {
      const unsigned int len = d2.length();
      mPUSHs(sv_2mortal(newRV_noinc((SV *)real_1d_array_to_av(aTHX_ d2))));
    }
  %};

void
spline1dconvdiff2cubic(real_1d_array x, real_1d_array y, ae_int_t n,
                       ae_int_t boundltype, double boundl,
                       ae_int_t boundrtype, double boundr,
                       real_1d_array x2, const ae_int_t n2)
  %code{%
    real_1d_array y2, d2, dd2;
    alglib::spline1dconvdiff2cubic(x, y, n, boundltype, boundl, boundrtype, boundr, x2, n2, y2, d2, dd2);
    EXTEND(SP, 3);
    {
      const unsigned int len = y2.length();
      mPUSHs(sv_2mortal(newRV_noinc((SV *)real_1d_array_to_av(aTHX_ y2))));
    }
    {
      const unsigned int len = d2.length();
      mPUSHs(sv_2mortal(newRV_noinc((SV *)real_1d_array_to_av(aTHX_ d2))));
    }
    {
      const unsigned int len = dd2.length();
      mPUSHs(sv_2mortal(newRV_noinc((SV *)real_1d_array_to_av(aTHX_ dd2))));
    }
  %};

spline1dinterpolant*
spline1dbuildcatmullrom(real_1d_array x, real_1d_array y, ae_int_t n,
                        ae_int_t boundtype = 0, double tension = 0)
  %code{%
    const char CLASS[] = "Math::Alglib::Interpolation::Spline1dInterpolant";
    RETVAL = new alglib::spline1dinterpolant();
    alglib::spline1dbuildcatmullrom(x, y, n, boundtype, tension, *RETVAL);
  %};

spline1dinterpolant*
spline1dbuildhermite(real_1d_array x, real_1d_array y, real_1d_array d)
  %code{%
    const char CLASS[] = "Math::Alglib::Interpolation::Spline1dInterpolant";
    RETVAL = new alglib::spline1dinterpolant();
    alglib::spline1dbuildhermite(x, y, d, *RETVAL);
  %};

{%
spline1dinterpolant*
spline1dbuildakima(real_1d_array x, real_1d_array y)
  ALIAS:
    spline1dbuildmonotone = 1
  CODE:
    const char CLASS[] = "Math::Alglib::Interpolation::Spline1dInterpolant";
    RETVAL = new alglib::spline1dinterpolant();
    if (ix == 0)
      alglib::spline1dbuildakima(x, y, *RETVAL);
    else
      alglib::spline1dbuildmonotone(x, y, *RETVAL);
  OUTPUT: RETVAL
%}

{%
AV *
polynomialfit(real_1d_array x, real_1d_array y, const ae_int_t m)
  CODE:
    sv_2mortal((SV *)RETVAL);
    alglib::polynomialfitreport rep;
    ae_int_t info;
    alglib::barycentricinterpolant *bary = new alglib::barycentricinterpolant();

    alglib::polynomialfit(x, y, m, info, *bary, rep);

    av_push(RETVAL, newSViv(info));
    av_push(RETVAL, ptr_to_perl_obj(aTHX_ bary, "Math::Alglib::Interpolation::BarycentricInterpolant"));
    av_push(RETVAL, polynomialfitreport_to_hvref(aTHX_ rep));
  OUTPUT: RETVAL
%}

{%
AV *
polynomialfitwc(real_1d_array x, real_1d_array y, real_1d_array w, real_1d_array xc, real_1d_array yc, integer_1d_array dc, const ae_int_t m)
  CODE:
    sv_2mortal((SV *)RETVAL);
    alglib::polynomialfitreport rep;
    ae_int_t info;
    alglib::barycentricinterpolant *bary = new alglib::barycentricinterpolant();

    alglib::polynomialfitwc(x, y, w, xc, yc, dc, m, info, *bary, rep);

    av_push(RETVAL, newSViv(info));
    av_push(RETVAL, ptr_to_perl_obj(aTHX_ bary, "Math::Alglib::Interpolation::BarycentricInterpolant"));
    av_push(RETVAL, polynomialfitreport_to_hvref(aTHX_ rep));
  OUTPUT: RETVAL
%}

{%
AV *
barycentricfitfloaterhormannwc(real_1d_array x, real_1d_array y, real_1d_array w, const ae_int_t n, real_1d_array xc, real_1d_array yc, integer_1d_array dc, const ae_int_t k, ae_int_t m)
  CODE:
    sv_2mortal((SV *)RETVAL);
    alglib::barycentricfitreport rep;
    ae_int_t info;
    alglib::barycentricinterpolant *bary = new alglib::barycentricinterpolant();

    alglib::barycentricfitfloaterhormannwc(x, y, w, n, xc, yc, dc, k, m, info, *bary, rep);

    av_push(RETVAL, newSViv(info));
    av_push(RETVAL, ptr_to_perl_obj(aTHX_ bary, "Math::Alglib::Interpolation::BarycentricInterpolant"));
    av_push(RETVAL, barycentricfitreport_to_hvref(aTHX_ rep));
  OUTPUT: RETVAL
%}

{%
AV *
barycentricfitfloaterhormann(real_1d_array x, real_1d_array y, const ae_int_t n, ae_int_t m)
  CODE:
    sv_2mortal((SV *)RETVAL);
    alglib::barycentricfitreport rep;
    ae_int_t info;
    alglib::barycentricinterpolant *bary = new alglib::barycentricinterpolant();

    alglib::barycentricfitfloaterhormann(x, y, n, m, info, *bary, rep);

    av_push(RETVAL, newSViv(info));
    av_push(RETVAL, ptr_to_perl_obj(aTHX_ bary, "Math::Alglib::Interpolation::BarycentricInterpolant"));
    av_push(RETVAL, barycentricfitreport_to_hvref(aTHX_ rep));
  OUTPUT: RETVAL
%}

{%
AV *
spline1dfitpenalized(real_1d_array x, real_1d_array y, const ae_int_t m, const double rho)
  CODE:
    sv_2mortal((SV *)RETVAL);
    alglib::spline1dfitreport rep;
    ae_int_t info;
    alglib::spline1dinterpolant *spl = new alglib::spline1dinterpolant();

    alglib::spline1dfitpenalized(x, y, m, rho, info, *spl, rep);

    av_push(RETVAL, newSViv(info));
    av_push(RETVAL, ptr_to_perl_obj(aTHX_ spl, "Math::Alglib::Interpolation::Spline1dInterpolant"));
    av_push(RETVAL, spline1dfitreport_to_hvref(aTHX_ rep));
  OUTPUT: RETVAL
%}

{%
AV *
spline1dfitpenalizedw(real_1d_array x, real_1d_array y, real_1d_array w, const ae_int_t m, const double rho)
  CODE:
    sv_2mortal((SV *)RETVAL);
    alglib::spline1dfitreport rep;
    ae_int_t info;
    alglib::spline1dinterpolant *spl = new alglib::spline1dinterpolant();

    alglib::spline1dfitpenalizedw(x, y, w, m, rho, info, *spl, rep);

    av_push(RETVAL, newSViv(info));
    av_push(RETVAL, ptr_to_perl_obj(aTHX_ spl, "Math::Alglib::Interpolation::Spline1dInterpolant"));
    av_push(RETVAL, spline1dfitreport_to_hvref(aTHX_ rep));
  OUTPUT: RETVAL
%}


{%
AV *
spline1dfitcubicwc(real_1d_array x, real_1d_array y, real_1d_array w, real_1d_array xc, real_1d_array yc, integer_1d_array dc, const ae_int_t m)
  ALIAS:
    spline1dfithermitewc = 1
  CODE:
    sv_2mortal((SV *)RETVAL);
    alglib::spline1dfitreport rep;
    ae_int_t info;
    alglib::spline1dinterpolant *spl = new alglib::spline1dinterpolant();

    if (ix == 0)
      alglib::spline1dfitcubicwc(x, y, w, xc, yc, dc, m, info, *spl, rep);
    else
      alglib::spline1dfithermitewc(x, y, w, xc, yc, dc, m, info, *spl, rep);

    av_push(RETVAL, newSViv(info));
    av_push(RETVAL, ptr_to_perl_obj(aTHX_ spl, "Math::Alglib::Interpolation::Spline1dInterpolant"));
    av_push(RETVAL, spline1dfitreport_to_hvref(aTHX_ rep));
  OUTPUT: RETVAL
%}

{%
AV *
spline1dfitcubic(real_1d_array x, real_1d_array y, const ae_int_t m)
  ALIAS:
    spline1dfithermite = 1
  CODE:
    sv_2mortal((SV *)RETVAL);
    alglib::spline1dfitreport rep;
    ae_int_t info;
    alglib::spline1dinterpolant *spl = new alglib::spline1dinterpolant();

    if (ix == 0)
      alglib::spline1dfitcubic(x, y, m, info, *spl, rep);
    else
      alglib::spline1dfithermite(x, y, m, info, *spl, rep);

    av_push(RETVAL, newSViv(info));
    av_push(RETVAL, ptr_to_perl_obj(aTHX_ spl, "Math::Alglib::Interpolation::Spline1dInterpolant"));
    av_push(RETVAL, spline1dfitreport_to_hvref(aTHX_ rep));
  OUTPUT: RETVAL
%}

{%
AV *
lsfitlinearw(real_1d_array y, real_1d_array w, real_2d_array fmatrix)
  CODE:
    sv_2mortal((SV *)RETVAL);
    alglib::lsfitreport rep;
    ae_int_t info;
    real_1d_array c;

    alglib::lsfitlinearw(y, w, fmatrix, info, c, rep);

    av_push(RETVAL, newSViv(info));
    av_push(RETVAL, newRV_noinc((SV *)real_1d_array_to_av(aTHX_ c)));
    av_push(RETVAL, lsfitreport_to_hvref(aTHX_ rep));
  OUTPUT: RETVAL
%}

{%
AV *
lsfitlinearwc(real_1d_array y, real_1d_array w, real_2d_array fmatrix, real_2d_array cmatrix)
  CODE:
    sv_2mortal((SV *)RETVAL);
    alglib::lsfitreport rep;
    ae_int_t info;
    real_1d_array c;

    alglib::lsfitlinearwc(y, w, fmatrix, cmatrix, info, c, rep);

    av_push(RETVAL, newSViv(info));
    av_push(RETVAL, newRV_noinc((SV *)real_1d_array_to_av(aTHX_ c)));
    av_push(RETVAL, lsfitreport_to_hvref(aTHX_ rep));
  OUTPUT: RETVAL
%}

{%
AV *
lsfitlinear(real_1d_array y, real_2d_array fmatrix)
  CODE:
    sv_2mortal((SV *)RETVAL);
    alglib::lsfitreport rep;
    ae_int_t info;
    real_1d_array c;

    alglib::lsfitlinear(y, fmatrix, info, c, rep);

    av_push(RETVAL, newSViv(info));
    av_push(RETVAL, newRV_noinc((SV *)real_1d_array_to_av(aTHX_ c)));
    av_push(RETVAL, lsfitreport_to_hvref(aTHX_ rep));
  OUTPUT: RETVAL
%}

{%
AV *
lsfitlinearc(real_1d_array y, real_2d_array fmatrix, real_2d_array cmatrix)
  CODE:
    sv_2mortal((SV *)RETVAL);
    alglib::lsfitreport rep;
    ae_int_t info;
    real_1d_array c;

    alglib::lsfitlinearc(y, fmatrix, cmatrix, info, c, rep);

    av_push(RETVAL, newSViv(info));
    av_push(RETVAL, newRV_noinc((SV *)real_1d_array_to_av(aTHX_ c)));
    av_push(RETVAL, lsfitreport_to_hvref(aTHX_ rep));
  OUTPUT: RETVAL
%}
