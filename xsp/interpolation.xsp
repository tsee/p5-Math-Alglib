#include <vector>
#include <interpolation.h>
#include <ap.h>

#include <perl_myinit.h>

%module{Math::Alglib};
%package{Math::Alglib::Interpolation};

//////////////////////////////////////////////////////////////////////
%name{Math::Alglib::Interpolation::IdwInterpolant}
class idwinterpolant {
  ~idwinterpolant();

  double
  idwcalc(alglib::real_1d_array x)
    %code{%
      RETVAL = alglib::idwcalc(*THIS, x);
    %};
};

//////////////////////////////////////////////////////////////////////
%name{Math::Alglib::Interpolation::BarycentricInterpolant}
class barycentricinterpolant {
  ~barycentricinterpolant();

  double
  barycentriccalc(const double t)
    %code{%
      RETVAL = alglib::barycentriccalc(*THIS, t);
    %};

  std::vector<double>
  barycentricdiff1(const double t)
    %code{%
      RETVAL.resize(2);
      alglib::barycentricdiff1(*THIS, t, RETVAL[0], RETVAL[1]);
    %};

  std::vector<double>
  barycentricdiff2(const double t)
    %code{%
      RETVAL.resize(3);
      alglib::barycentricdiff2(*THIS, t, RETVAL[0], RETVAL[1], RETVAL[2]);
    %};

  void
  barycentriclintransx(const double ca, const double cb)
    %code{% alglib::barycentriclintransx(*THIS, ca, cb); %};

  void
  barycentriclintransy(const double ca, const double cb)
    %code{% alglib::barycentriclintransy(*THIS, ca, cb); %};

  void
  barycentricunpack()
    %code%{
      ae_int_t n;
      real_1d_array x, y, w;
      barycentricunpack(*THIS, n, x, y, w);
      EXTEND(SP, 4);
      mPUSHi(n);
      mPUSHs(sv_2mortal(newRV_noinc((SV *)real_1d_array_to_av(aTHX_ x))));
      mPUSHs(sv_2mortal(newRV_noinc((SV *)real_1d_array_to_av(aTHX_ y))));
      mPUSHs(sv_2mortal(newRV_noinc((SV *)real_1d_array_to_av(aTHX_ w))));
      XSRETURN(4);
    %};

  alglib::real_1d_array
  polynomialbar2cheb(const double a, const double b)
    %code{% alglib::polynomialbar2cheb(*THIS, a, b, RETVAL); %};

  alglib::real_1d_array
  polynomialbar2pow(const double c, const double s)
    %code{% alglib::polynomialbar2pow(*THIS, c, s, RETVAL); %};
};

//////////////////////////////////////////////////////////////////////
%name{Math::Alglib::Interpolation::Spline1dInterpolant}
class spline1dinterpolant {
  ~spline1dinterpolant();

  double spline1dcalc(const double x)
    %code{%
      RETVAL = alglib::spline1dcalc(*THIS, x);
    %};

  void
  spline1ddiff(const double x)
    %code{%
      double s, ds, d2s;
      alglib::spline1ddiff(*THIS, x, s, ds, d2s);
      EXTEND(SP, 3);
      mPUSHn(s); mPUSHn(ds); mPUSHn(d2s);
    %};

  alglib::real_2d_array
  spline1dunpack()
    %code{%
      ae_int_t n;
      alglib::spline1dunpack(*THIS, n, RETVAL);
    %};

  void
  spline1dlintransx(const double a, const double b)
    %code{% alglib::spline1dlintransx(*THIS, a, b); %};

  void
  spline1dlintransy(const double a, const double b)
    %code{% alglib::spline1dlintransy(*THIS, a, b); %};

  double
  spline1dintegrate(const double x)
    %code{%
      RETVAL = alglib::spline1dintegrate(*THIS, x);
    %};

};


//////////////////////////////////////////////////////////////////////
%package{Math::Alglib::Interpolation};

idwinterpolant*
idwbuildmodifiedshepard(alglib::real_2d_array xy, const ae_int_t n, const ae_int_t nx,
                         const ae_int_t d, const ae_int_t nq, const ae_int_t nw)
  %code{%
    const char CLASS[] = "Math::Alglib::Interpolation::IdwInterpolant";
    RETVAL = new alglib::idwinterpolant();
    alglib::idwbuildmodifiedshepard(xy, n, nx, d, nq, nw, *RETVAL);
  %};

idwinterpolant*
idwbuildmodifiedshepardr(alglib::real_2d_array xy, const ae_int_t n, const ae_int_t nx, const double r)
  %code{%
    const char CLASS[] = "Math::Alglib::Interpolation::IdwInterpolant";
    RETVAL = new alglib::idwinterpolant();
    alglib::idwbuildmodifiedshepardr(xy, n, nx, r, *RETVAL);
  %};

idwinterpolant*
idwbuildnoisy(alglib::real_2d_array xy, const ae_int_t n, const ae_int_t nx,
              const ae_int_t d, const ae_int_t nq, const ae_int_t nw)
  %code{%
    const char CLASS[] = "Math::Alglib::Interpolation::IdwInterpolant";
    RETVAL = new alglib::idwinterpolant();
    alglib::idwbuildnoisy(xy, n, nx, d, nq, nw, *RETVAL);
  %};

//////////////////////////////////////////////////////////////////////
barycentricinterpolant*
barycentricbuildxyw(alglib::real_1d_array x, alglib::real_1d_array y, alglib::real_1d_array w, const ae_int_t n)
  %code{%
    const char CLASS[] = "Math::Alglib::Interpolation::BarycentricInterpolant";
    RETVAL = new alglib::barycentricinterpolant();
    alglib::barycentricbuildxyw(x, y, w, n, *RETVAL);
  %};

barycentricinterpolant*
barycentricbuildfloaterhormann(alglib::real_1d_array x, alglib::real_1d_array y, const ae_int_t n, const ae_int_t d)
  %code{%
    const char CLASS[] = "Math::Alglib::Interpolation::BarycentricInterpolant";
    RETVAL = new alglib::barycentricinterpolant();
    alglib::barycentricbuildfloaterhormann(x, y, n, d, *RETVAL);
  %};

barycentricinterpolant*
polynomialcheb2bar(alglib::real_1d_array t, const double a, const double b)
  %code{%
    const char CLASS[] = "Math::Alglib::Interpolation::BarycentricInterpolant";
    RETVAL = new alglib::barycentricinterpolant();
    alglib::polynomialcheb2bar(t, a, b, *RETVAL);
  %};

barycentricinterpolant*
polynomialpow2bar(alglib::real_1d_array a, const ae_int_t n, const double c, const double s)
  %code{%
    const char CLASS[] = "Math::Alglib::Interpolation::BarycentricInterpolant";
    RETVAL = new alglib::barycentricinterpolant();
    alglib::polynomialpow2bar(a, n, c, s, *RETVAL);
  %};

barycentricinterpolant*
polynomialbuild(alglib::real_1d_array x, alglib::real_1d_array y)
  %code{%
    const char CLASS[] = "Math::Alglib::Interpolation::BarycentricInterpolant";
    RETVAL = new alglib::barycentricinterpolant();
    alglib::polynomialbuild(x, y, *RETVAL);
  %};

{%
barycentricinterpolant*
polynomialbuildcheb1(const double a, const double b, alglib::real_1d_array y)
  PREINIT:
    const char CLASS[] = "Math::Alglib::Interpolation::BarycentricInterpolant";
  ALIAS:
    alglib::polynomialbuildeqdist = 1
    alglib::polynomialbuildcheb2 = 2
  CODE:
    RETVAL = new alglib::barycentricinterpolant();
    if (ix == 0)
      alglib::polynomialbuildcheb1(a, b, y, *RETVAL);
    else if (ix == 1)
      alglib::polynomialbuildeqdist(a, b, y, *RETVAL);
    else
      alglib::polynomialbuildcheb2(a, b, y, *RETVAL);
  OUTPUT: RETVAL
%}
//////////////////////////////////////////////////////////////////////

double polynomialcalceqdist(const double a, const double b, alglib::real_1d_array f, const double t);
double polynomialcalccheb1(const double a, const double b, alglib::real_1d_array f, const double t);
double polynomialcalccheb2(const double a, const double b, alglib::real_1d_array f, const double t);


//////////////////////////////////////////////////////////////////////
spline1dinterpolant*
spline1dbuildlinear(alglib::real_1d_array x, alglib::real_1d_array y)
  %code{%
    const char CLASS[] = "Math::Alglib::Interpolation::Spline1dInterpolant";
    RETVAL = new alglib::spline1dinterpolant();
    alglib::spline1dbuildlinear(x, y, *RETVAL);
  %};

spline1dinterpolant*
spline1dbuildcubic(alglib::real_1d_array x, alglib::real_1d_array y, ae_int_t n,
                   ae_int_t boundltype = 0, double boundl = 0,
                   ae_int_t boundrtype = 0, double boundr = 0)
  %code{%
    const char CLASS[] = "Math::Alglib::Interpolation::Spline1dInterpolant";
    RETVAL = new alglib::spline1dinterpolant();
    alglib::spline1dbuildcubic(x, y, n, boundltype, boundl, boundrtype, boundr, *RETVAL);
  %};

alglib::real_1d_array
spline1dgriddiffcubic(alglib::real_1d_array x, alglib::real_1d_array y, ae_int_t n,
                      ae_int_t boundltype = 0, double boundl = 0,
                      ae_int_t boundrtype = 0, double boundr = 0)
  %code{%
    alglib::spline1dgriddiffcubic(x, y, n, boundltype, boundl, boundrtype, boundr, RETVAL);
  %};


alglib::real_1d_array
spline1dconvcubic(alglib::real_1d_array x, alglib::real_1d_array y, ae_int_t n,
                  ae_int_t boundltype, double boundl,
                  ae_int_t boundrtype, double boundr,
                  alglib::real_1d_array x2, const ae_int_t n2)
  %code{%
    alglib::spline1dconvcubic(x, y, n, boundltype, boundl, boundrtype, boundr, x2, n2, RETVAL);
  %};

void
spline1dconvdiffcubic(alglib::real_1d_array x, alglib::real_1d_array y, ae_int_t n,
                      ae_int_t boundltype, double boundl,
                      ae_int_t boundrtype, double boundr,
                      alglib::real_1d_array x2, const ae_int_t n2)
  %code{%
    alglib::real_1d_array y2, d2;
    alglib::spline1dconvdiffcubic(x, y, n, boundltype, boundl, boundrtype, boundr, x2, n2, y2, d2);
    EXTEND(SP, 2);
    {
      const unsigned int len = y2.length();
      mPUSHs(sv_2mortal(newRV_noinc((SV *)real_1d_array_to_av(aTHX_ y2))));
    }
    {
      const unsigned int len = d2.length();
      mPUSHs(sv_2mortal(newRV_noinc((SV *)real_1d_array_to_av(aTHX_ d2))));
    }
  %};

void
spline1dconvdiff2cubic(alglib::real_1d_array x, alglib::real_1d_array y, ae_int_t n,
                       ae_int_t boundltype, double boundl,
                       ae_int_t boundrtype, double boundr,
                       alglib::real_1d_array x2, const ae_int_t n2)
  %code{%
    alglib::real_1d_array y2, d2, dd2;
    alglib::spline1dconvdiff2cubic(x, y, n, boundltype, boundl, boundrtype, boundr, x2, n2, y2, d2, dd2);
    EXTEND(SP, 3);
    {
      const unsigned int len = y2.length();
      mPUSHs(sv_2mortal(newRV_noinc((SV *)real_1d_array_to_av(aTHX_ y2))));
    }
    {
      const unsigned int len = d2.length();
      mPUSHs(sv_2mortal(newRV_noinc((SV *)real_1d_array_to_av(aTHX_ d2))));
    }
    {
      const unsigned int len = dd2.length();
      mPUSHs(sv_2mortal(newRV_noinc((SV *)real_1d_array_to_av(aTHX_ dd2))));
    }
  %};

spline1dinterpolant*
spline1dbuildcatmullrom(alglib::real_1d_array x, alglib::real_1d_array y, ae_int_t n,
                        ae_int_t boundtype = 0, double tension = 0)
  %code{%
    const char CLASS[] = "Math::Alglib::Interpolation::Spline1dInterpolant";
    RETVAL = new alglib::spline1dinterpolant();
    alglib::spline1dbuildcatmullrom(x, y, n, boundtype, tension, *RETVAL);
  %};

spline1dinterpolant*
spline1dbuildhermite(alglib::real_1d_array x, alglib::real_1d_array y, alglib::real_1d_array d)
  %code{%
    const char CLASS[] = "Math::Alglib::Interpolation::Spline1dInterpolant";
    RETVAL = new alglib::spline1dinterpolant();
    alglib::spline1dbuildhermite(x, y, d, *RETVAL);
  %};

{%
spline1dinterpolant*
spline1dbuildakima(alglib::real_1d_array x, alglib::real_1d_array y)
  ALIAS:
    spline1dbuildmonotone = 1
  CODE:
    const char CLASS[] = "Math::Alglib::Interpolation::Spline1dInterpolant";
    RETVAL = new alglib::spline1dinterpolant();
    if (ix == 0)
      alglib::spline1dbuildakima(x, y, *RETVAL);
    else
      alglib::spline1dbuildmonotone(x, y, *RETVAL);
  OUTPUT: RETVAL
%}

