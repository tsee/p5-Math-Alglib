#!perl
use strict;
use warnings;
use Capture::Tiny qw(capture_stdout);

my $struct_to_hash = "author_tools/struct_to_hash.pl";
my $outfile = "src/perl_conversion_functions.h";

print "Writing output to file '$outfile'.\n";

open my $fh, ">", $outfile or die $!;
print $fh <<"HERE";
#ifndef PERL_CONVERSION_FUNCTIONS_H_
#define PERL_CONVERSION_FUNCTIONS_H_

/* WARNING!
 * This code is autogenerated. Have a look at author_tools/regen.pl and
 * its friend author_tools/struct_to_hash.pl!
 */

#include <EXTERN.h>
#include <perl.h>

#include <ap.h>
#include <interpolation.h>

SV *
ae_vector_to_perl(pTHX_ const alglib_impl::ae_vector &vec, alglib_impl::ae_datatype datatype = 0)
{
  AV *av = newAV();
  SV *rv = newRV_noinc((SV*)av);

  size_t n = (size_t)vec.cnt;
  size_t i;

  if (datatype == 0)
    datatype = vec.datatype;

  av_fill(av, n-1);
  if (datatype == alglib_impl::DT_BOOL) {
    ae_bool *v = vec.ptr.p_bool;
    for (i = 0; i < n; ++i)
      av_store(av, i, v[i] ? &PL_sv_yes : &PL_sv_no);
  }
  else if (datatype == alglib_impl::DT_INT) {
    alglib_impl::ae_int_t *v = vec.ptr.p_int;
    for (i = 0; i < n; ++i)
      av_store(av, i, newSViv((IV)v[i]));
  }
  else if (datatype == alglib_impl::DT_REAL) {
    double *v = vec.ptr.p_double;
    for (i = 0; i < n; ++i)
      av_store(av, i, newSVnv((NV)v[i]));
  }
  else if (datatype == alglib_impl::DT_COMPLEX) {
    alglib_impl::ae_complex *v = vec.ptr.p_complex;
    for (i = 0; i < n; ++i) {
      AV *a = newAV();
      av_store(av, i, newRV_noinc((SV *)a));
      av_push(a, newSVnv(v[i].x));
      av_push(a, newSVnv(v[i].y));
    }
  }

  return rv;
}

SV *
ae_matrix_to_perl(pTHX_ const alglib_impl::ae_matrix &mat, alglib_impl::ae_datatype datatype = 0)
{
  // TODO: This does row major. Maybe alglib does column major? Verify.

  if (datatype == 0)
    datatype = mat.datatype;

  const size_t rows = mat.rows;
  const size_t cols = mat.cols;

  AV *av = newAV();
  SV *rv = newRV_noinc((SV*)av);

  size_t i, j;

  av_fill(av, rows-1);
  if (mat.datatype == alglib_impl::DT_BOOL) {
    ae_bool **v = mat.ptr.pp_bool;
    for (i = 0; i < rows; ++i) {
      ae_bool *vr = v[i];
      AV *row = newAV();
      av_store(av, i, newRV_noinc((SV *)row));
      for (j = 0; j < rows; ++j)
        av_store(row, j, vr[j] ? &PL_sv_yes : &PL_sv_no);
    }
  }
  else if (mat.datatype == alglib_impl::DT_INT) {
    alglib_impl::ae_int_t **v = mat.ptr.pp_int;
    for (i = 0; i < rows; ++i) {
      alglib_impl::ae_int_t *vr = v[i];
      AV *row = newAV();
      av_store(av, i, newRV_noinc((SV *)row));
      for (j = 0; j < rows; ++j)
        av_store(row, j, newSViv((IV)vr[j]));
    }
  }
  else if (mat.datatype == alglib_impl::DT_REAL) {
    double **v = mat.ptr.pp_double;
    for (i = 0; i < rows; ++i) {
      double *vr = v[i];
      AV *row = newAV();
      av_store(av, i, newRV_noinc((SV *)row));
      for (j = 0; j < rows; ++j)
        av_store(row, j, newSVnv((NV)vr[j]));
    }
  }
  else if (mat.datatype == alglib_impl::DT_COMPLEX) {
    alglib_impl::ae_complex **v = mat.ptr.pp_complex;
    for (i = 0; i < rows; ++i) {
      alglib_impl::ae_complex *vr = v[i];
      AV *row = newAV();
      av_store(av, i, newRV_noinc((SV *)row));
      for (j = 0; j < rows; ++j) {
        AV *a = newAV();
        av_store(row, i, newRV_noinc((SV *)a));
        const alglib_impl::ae_complex &c = vr[j];
        av_push(a, newSVnv(c.x));
        av_push(a, newSVnv(c.y));
      }
    }
  }

  return rv;
}

/* used by the real_1d_array typemap, but also usable separately */
AV *
real_1d_array_to_av(pTHX_ const alglib::real_1d_array &x)
{
  const unsigned int len = x.length();
  AV *av = newAV();
  unsigned int i;
  av_extend(av, len-1);
  for (i = 0; i < len; ++i)
    av_store(av, i, newSVnv(x[i]));
  return av;
}

void
av_to_real_1d_array(pTHX_ AV *av, alglib::real_1d_array &x)
{
  const unsigned int len = av_len(av)+1;
  unsigned int i;
  SV **elem;
  x.setlength(len);
  for (i = 0; i < len; ++i) {
    elem = av_fetch(av, i, 0);
    if (elem == NULL)
      x[i] = 0.;
    else
      x[i] = SvNV(*elem);
  }
}


/* used by the real_2d_array typemap, but also usable separately */
AV *
real_2d_array_to_av(pTHX_ const alglib::real_2d_array &x)
{
  AV* av = newAV();
  const unsigned int rows = x.rows();
  const unsigned int cols = x.cols();
  av_extend(av, rows-1);
  for (unsigned int i = 0; i < rows; i++) {
    AV *iav = newAV();
    const double *row = x[i];
    av_extend(iav, cols-1);
    av_store(av, i, newRV_noinc((SV *)iav));
    for (unsigned int j = 0; j < cols; j++) {
      av_store(iav, j, newSVnv(row[j]));
    }
  }
  return av;
}

/* used by the integer_1d_array typemap, but also usable separately */
AV *
integer_1d_array_to_av(pTHX_ const alglib::integer_1d_array &x)
{
  const unsigned int len = x.length();
  AV *av = newAV();
  unsigned int i;
  av_extend(av, len-1);
  for (i = 0; i < len; ++i)
    av_store(av, i, newSViv(x[i]));
  return av;
}


/* used by integration.h to return an arrayref of a status int
 * followed by two real_1d_array's */
SV *
integration_return_status_ary_ary(pTHX_ IV info,
                                  const alglib::real_1d_array &x,
                                  const alglib::real_1d_array &w,
                                  alglib::real_1d_array *opt = NULL)
{
  AV *av = newAV();
  SV *retval = newRV_noinc((SV *)av);
  av_extend(av, opt == NULL ? 2 : 3);
  av_store(av, 0, newSViv(info));
  av_store(av, 1, newRV_noinc((SV *) real_1d_array_to_av(aTHX_ x)));
  av_store(av, 2, newRV_noinc((SV *) real_1d_array_to_av(aTHX_ w)));
  if (opt != NULL)
    av_store(av, 3, newRV_noinc((SV *) real_1d_array_to_av(aTHX_ *opt)));
  return retval;
}

// This could be auto-generated by struct-to-hashref but the various
// members are not always set, so that would be a disaster.
/* turns lsfitreport into a hashref for output */
SV *
lsfitreport_to_hvref(pTHX_ const alglib::lsfitreport &rep)
{
  HV* hv = newHV();
  SV *rv = newRV_noinc((SV*)hv);
  hv_stores(hv, "taskrcond", newSVnv(rep.taskrcond));
  hv_stores(hv, "iterationscount", newSViv(rep.iterationscount));
  hv_stores(hv, "varidx", newSViv(rep.varidx));
  hv_stores(hv, "rmserror", newSVnv(rep.rmserror));
  hv_stores(hv, "avgerror", newSVnv(rep.avgerror));
  hv_stores(hv, "avgrelerror", newSVnv(rep.avgrelerror));
  hv_stores(hv, "maxerror", newSVnv(rep.maxerror));
  hv_stores(hv, "wrmserror", newSVnv(rep.wrmserror));
  hv_stores(hv, "r2", newSVnv(rep.r2));

  // The following params seem to be unitialized?
  //hv_stores(hv, "covpar", a ...
  //  ae_matrix covpar;
  //hv_stores(hv, "errpar", ae_vector_to_perl(aTHX_ (const alglib_impl::ae_vector &)rep.errpar));
  //hv_stores(hv, "errcurve", ae_vector_to_perl(aTHX_ (const alglib_impl::ae_vector &)rep.errcurve));
  //hv_stores(hv, "noise", ae_vector_to_perl(aTHX_ (const alglib_impl::ae_vector &)rep.noise));
  return rv;
}

/* Given an arbitrary ptr and a class name, returns a blessed scalar,
 * traditional XS style... */
SV *
ptr_to_perl_obj(pTHX_ void *ptr, const char *CLASS)
{
  SV *obj;
  obj = newSV(0);
  sv_setref_pv(obj, CLASS, ptr);
  return obj;
}

HERE

my $typemap = "xsp/mytype.map";
my $functions = [
#  {
#    file => "src/diffequations.h",
#    struct_name => "odesolverstate",
#    struct_fq => "alglib_impl::odesolverstate",
#    c_to_perl_function => "odesolverstate_to_perl_hash",
#  },
  {
    file => "src/interpolation.h",
    struct_name => "barycentricfitreport",
    struct_fq => "alglib::barycentricfitreport",
    c_to_perl_function => "barycentricfitreport_to_perl_hash",
  },
  {
    file => "src/interpolation.h",
    struct_name => "polynomialfitreport",
    struct_fq => "alglib::polynomialfitreport",
    c_to_perl_function => "polynomialfitreport_to_perl_hash",
  },
  {
    file => "src/interpolation.h",
    struct_name => "spline1dfitreport",
    struct_fq => "alglib::spline1dfitreport",
    c_to_perl_function => "spline1dfitreport_to_perl_hash",
  },
];

# emit header include
foreach my $func (@$functions) {
  my $header = $func->{file};
  $header =~ s/^src\///; # FIXME hack
  print $fh "#include <$header>\n";
}

print $fh "\nusing namespace alglib; /* FIXME hack */\n\n";

# emit function bodies
foreach my $func (@$functions) {
  my @cmd = (
    $^X,
    $struct_to_hash,
    "--typemap", $typemap,
    (map {("--$_", $func->{$_})} keys %$func)
  );

  print "Regenerating function '$func->{c_to_perl_function}' from struct '$func->{struct_name}' in '$func->{file}'...\n";
  my $stdout = capture_stdout {
    system(@cmd) and die "Failed to run '@cmd': $!";
  };

  #print $fh "\n#line 1 \"@cmd\"\n";
  print $fh $stdout;
}

print $fh <<HERE;

#endif
HERE

